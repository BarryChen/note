
## ch1 关于对象

### C++ 对象模型

```cpp
class Point {
public:
    Point( float xval );
    virtual ~Point();

    float x() const;
    static int PointCount();

protected:
    virtual ostream& print( ostream &os ) const;

    float _x;
    static int _point_count;
};
```

1. 非静态数据成员被配置在每一个类对象内
2. 静态数据成员被存放在类对象之外
3. 静态和非静态函数成员也被放在类对象之外

对虚函数的支持：
+ 每一个类产生出一堆指向虚函数的指针，放在表格之中，这个表格被称为 **virtual table**
+ 每一而类对象被安插一个指针，指向相关的 virtual table，这个指针称为 **vptr**。
vptr 的设定和重置都由每一个类的构造函数、析构函数和拷贝复制运算符自动完成。
每一个类所关联的 **type_info** 对象(用来支持 runtime type identification， RTTI)
也经由 virtual table 被指出来，通常放在表格的第一个 slot

![](https://img-blog.csdnimg.cn/2019062722314025.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)


### 类对象的大小
+ 非静态数据成员的大小
+ 内存对齐
+ vptr

### 指针的类型
转换(cast)其实是一个种编译器指令，大部分情况下它并不改变一个指针所含的真正地址，
它只影响被指出的内存的大小和其内容

### 加上多态后
一个指针或一个引用之所以支持多态，是因为它们并不引发内存中任何**与类型有关的内存委托操作**，
会受到改变的只有它们所指向的内存的**大小和内容解释方式**而已

当一个基类对象被直接初始化为一个子类对象时，基类对象会被切割以塞入较小的基类类型内存中，
子类将没有留下任何蛛丝马迹，多态于是不在呈现

## ch2 构造函数语意学

### 构造函数
什么时候编译器会合成一个重要的默认构造函数

#### 1.带有默认构造函数的类对象成员
如果一个类没有任何构造函数，但它内含一个成员对象，该成员对象有默认构造函数，
那么这个类的隐式默认构造函数就是重要的，编译器需要为这个类合成一个默认构造函数。

不过这个合成操作只有在构造函数被调用时才会发生

如果有多个类成员对象都要求构造函数初始化操作，将以成员对象在类中的声明顺序来调用各个构造函数

#### 2.带有默认构造函数的基类
如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，
那么这个派生类的默认构造函数会被视为重要的，因此会被合成出来

如果这个类有多个构造函数，但是没有默认构造函数，编译器会扩张每个构造函数，将调用必要的构造函数的代码加进去，
他不会合成一个新的默认构造函数

#### 3.带有一个虚函数的类
1. 类声明或继承一个虚函数
2. 类派生自一个继承串链，其中有一个或更多的虚基类

编译器必须为每个类的 **vptr** 设定初值，放置适当的虚函数表地址，这就是合成的默认构造函数

#### 4.带有一个虚基类的类
虚基类的实现方法在不同编译器之间有极大的差异，每一种的共同点在于必须使虚基类在其每一个派生类对象中的位置，
能够于执行期准备妥当

因此，编译器会生成某个东西在类对象构造期间被完成，对于类所定义的而每一个构造函数，编译器会安插那些允许每一个虚基类的执行期存取操作的代码

### 复制构造函数

有三种情况会调用复制构造函数：
1. 显示赋值`X xx = x;`
2. 作为函数参数
3. 作为函数返回值

以下四种情况会被合成复制构造函数：
1. 类内含有一个对象成员，而这个成员的类声明有复制构造函数(显示声明或编译器合成)
2. 类继承自一个基类，基类存在一个复制构造函数
3. 类声明有虚函数
4. 类派生自的继承串链中有虚基类

### 程序转化语义学

#### 在编译器层面做优化
```cpp
X bar() {
    X xx;
    // 处理 xx
    return xx;
}
```
编译器把其中的xx以_result取代：
```cpp
void var(X &_result) {
    // 默认构造函数被调用
    _result.X::X();
    // 直接处理 _result
    return;
}
```

这种优化称为 **Named Return Value(NRV)** 优化

这种优化是编译器默默完成的，而它是否被完成并不清楚


### memset、memcpy
只有在类不含有任何由编译器产生的内部成员时才能有效运行，
例如类内含有虚函数或内含一个虚基类，那么memset和memcpy将会导致vptr被改写
```cpp
class Shape {
public:
    // 这会改变内部的vptr
    Shape(){memset(this, 0, sizeof(Shape));}
    virtual ~Shape();
};
```

### 必须使用成员初始化列表
1. 初始化一个成员引用
2. 初始化一个 const 成员
3. 调用一个基类的构造函数，它有一组参数
4. 调用一个成员对象的构造函数，它有一组参数

编译器会一一操作初始化列表，以类中成员声明的顺序在构造函数之内安插初始化操作，并且在任何显示的用户代码之前