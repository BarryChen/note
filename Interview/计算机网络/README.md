# 腾讯OMG团队(实习)
## 1. 画出tcp头部的协议格式
![](https://github.com/liu-jianhao/note/blob/master/Interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E9%A6%96%E9%83%A8.png)

## 2. HTTP的报文头部
### 请求报文：它会向Web服务器请求一个动作
请求报文的格式：
+ 起始行：  `<method> <request-URL> <version>`
+ 头部：    `<headers>`
+ 主体：    `<entity-body>`

 
### 响应报文：它会将请求的结果返回给客户端。
响应报文的格式：
+ 起始行：  `<version> <status> <reason-phrase>`
+ 头部：    `<headers>`
+ 主体：    `<entity-body>`

## 从浏览器输入网址到显示页面的过程？
1. 浏览器向DNS服务器查询URL对应的IP地址
2. DNS返回IP地址
3. 浏览器打开TCP连接(默认为80)，并向Web服务器发送HTTP请求
4. 若页面发生跳转，服务器则以一个重定向响应，然后转到5，否则直接转到6
5. 浏览器跟随重定向，再次发送HTTP请求
6. 浏览器处理请求， 并发回HTML响应
7. 浏览器接受请求的页面源码
8. 浏览器开始渲染HTML
9. 浏览器发送嵌入到HTML中的对象请求
10. 浏览器进一步发送异步(Ajax)请求
11. 浏览器关闭TCP连接


## TIME_WAIT
完成主动关闭后，TCP结点接收到了FIN报文。这表示对端执行了一个被动关闭。
此时这个TCP结点将在TIME_WAIT状态中等待一段固定时间(BSD的MSL=30s，RFC 1122建议MSL=2min)
+ 确保TCP连接可靠地终止
    + 假设最后一个ACK报文丢失了，被动关闭的一方会重传它的FIN报文，主动关闭的一方保持在TIME_WAIT会重新发送ACK报文
    + 如果主动关闭的一方不存在了，那么TCP会针对对端重发的FIN报文发送一个RST
+ 为了确保任何老的报文在重新建立同样的连接之前在网络中超时消失
    + TCP的重传算法意味着可能会有重复的报文，并且根据路由的选择，这些重复的报文可能在连接已经终止之后才到达
    + TCP必须确保上一次连接中老的重复报文不会在新的连接中被当成合法的数据接收
    + 当TCP结点处于TIME_WAIT状态时是无法通过该结点创建新的连接的，这样就阻止了新连接的建立

### SO_REUSEADDR套接字选项
避免TCP服务重启，尝试将套接字绑定到当前已经同TCP结点相关联的端口上时出现的EADDRINUSE错误

## CLOSE_WAIT
TCP结点从对端收到FIN报文后将处于CLOSE_WAIT状态


## 什么是CDN(内容分发网络)?


## TCP的紧急指针？
占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 

当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。

因此，紧急指针指出了紧急数据的末尾在报文段中的位置。

## TCP粘包问题？
TCP通信机制的底层的粘包和拆包：当我们在接收消息的时候，显示不能认为读取到的报文就是个整包消息。如何区分一个整包消息，通常有如下五种做法：
1. 固定长度，例如每xxx 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定常消息的时候比较简单，每次读到指定长度的字节后再进行解码；
2. 通过回车换行符区分消息，例如HTTP协议。这类区分消息的方式多用于文本协议；
3. 通过特定的分隔符区分整包消息；
4. 通过在协议头/消息头中设置长度字段来标识整包消息
5. 通过协议号来确定解析协议的长度，由一个唯一协议标记就可以确定一个反序列化类，从而实现区分整包

## TCP的可靠性
1. 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。
由TCP传递给IP的信息单位称为报文段或段
2. 当TCP发送一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
3. 当TCP收到发自TCP连接另一端的数据，它将发送一个确认
4. TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。
如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
5. TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP将对收到的数据进行重新排序，
将收到的数据以正确的顺序交给应用层。
6. 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
7. TCP还提供流量控制


## TCP要点
### 序号
TCP提供有序的传输，所以每个数据段都要标上一个序号。一个Seq号的大小是根据上一个数据段的Seq号和长度相加而来。
注意这个长度不包括TCP头

### 发送限制
发送方要知道接收方的接收窗口和网络这两个限制因素哪一个更严格

### 发送窗口和MSS有什么关系
发送窗口决定了一口气能发多少个字节，而MSS决定了这些字节要分多少个包发完

### TCP Window Scale
由于TCP头中只给接收窗口值留了16bit(最大为65535)，Window Scale(TCP中的一个选项)的作用是向对方声明一个Shift count，
把它作为2的指数，在乘以TCP头中定义的接收窗口，就得到TCP接收窗口了

### 发送方要怎么避免拥塞？
发送方维护一个虚拟的拥塞窗口，通过以下算法尽可能接近拥塞点：
1. 连接刚建立时，发送方要把拥塞窗口的初始值定的很小，RFC建议是2个、3个或4个MSS
2. 如果发出去的包得到确认，表明没有达到拥塞点，可以增大拥塞窗口。
所以RFC建议的算法是每收到n个确认，可以把拥塞窗口增加n个MSS，这称为慢启动过程
3. 慢启动过程一段时间后，拥塞窗口达到一个较大的值。这时候不能再采用翻倍的慢启动算法，
RFC建议的算法是在每个往返时间增加1个MSS，例如发了16个MSS之后全部被确认，拥塞窗口就增加到17个MSS...
从慢启动过渡到拥塞避免的临界窗口值很有讲究。如果之前发生过拥塞，就把该拥塞点作为参考依据。
如果从来没有过拥塞就可以取一个较大的值，比如和最大接受窗口值相等

### 拥塞之后呢？
假如一段时间后没有收到确认，就认定包已经丢失了，只能重传了，这个过程称为超时重传
从发送原始包到重传该包的这段时间称为RTO(通过某个公式算出来)

![](https://img-blog.csdnimg.cn/201904112305519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)

重传之后的拥塞窗口该怎么调整？RFC建议把拥塞窗口降到1个MSS，然后再次进入慢启动过程。
这时临界窗口值就有参考依据了，RFC5681认为定为发生拥塞时没被确认的数据量的1/2，但不能小于2个MSS。
比如发了19个包出去，但只有3个包收到确认，那么临界窗口值就被定为16个包携带的数据量的1/2

超时重传会对性能有严重的影响，原因之一就是RTO阶段不能传数据，相当于浪费了一段时间；原因之二是拥塞窗口急剧减小

如果发生丢包，当后续的包到达接收方时，接收方会发现其Seq比期望的大，所以它每收到一个包就Ack一次期望的Seq号，提醒发送放重传
当发送方收到3个重复确认时，就意识到相应的包已经丢了，从而立即重传它，称为快速重传

如果在拥塞避免阶段发生了快速重传，是否需要像快速重传那样处理拥塞窗口？没必要。既然后续的包都到达了，说明网络并不拥塞
RFC5681建议临界窗口值应该设为发生拥塞时还没被确认的数据量的1/2，然后将拥塞窗口设置为临界窗口值增加3个MSS，
继续保留在拥塞避免阶段，这个过程称为快速恢复

![](https://img-blog.csdnimg.cn/20190411230556825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)

如果丢的包不止一个？比如2号和3号包丢失，1、4、5、6、7、8号都到达了接收方并触发Ack2。
对于发送方来说只能通过Ack2知道2号包丢失了，但并不知道还有哪些包丢失了，接下来该怎么传？
+ 方案一：全部重传，早期TCP就是这样处理的
+ 方案二：接收方收到重传过来的2号包之后，会回复一个Ack3，因此发送方推理出3号包也丢了，重传3号包，
接收方收到后就可回复Ack9，从此发送方就可以传新的包。这个方案称为NewReno，缺点是当丢失包多的时候会花费多个RTT时间重传
+ 方案三：接收方在Ack2号包的时候，顺便把接收到的包号也告诉发送方，所以这些Ack包应该是这样：
SACK=4-8和Ack=2，这样发送方就知道缺失了2-3号包，者纷纷方案称为SACK(TCP选项)


### 总结
+ 没有拥塞时，发送窗口越大性能越好，所以在带宽没有限制的条件下，应该尽量增大接受窗口，比如启用Scale Option
+ 超时重传对性能影响最大，因为它有一段时间RTO没有传输任何数据，而且拥塞窗口会被设成1个MSS，所以要尽量避免超时重传
+ 快速重传对性能影响小一些，因为它没有等待时间，而且拥塞窗口减小的幅度没那么大
+ SACK和NewReno有利于提高重传效率，提高传输性能

## 接收方怎么重组分片
每个分片都包含off=xxx，ID=xxx的信息，把ID相同的分片按照off值进行重组，
最后一个分片包含More fragments = 0 的flag(其他的为1)，因此接收方可以开始重组了

## TCP如何避免分片
TCP主动把数据分成小段再交给网络层，最大的分段大小为MSS，相当于MTU减去IP头和TCP头的大小

UDP则没有MSS的概念，分片和重组都会影响性能


## TCP BBR 拥塞控制算法
TCP BBR 致力于解决两个问题：
1. 在有一定丢包率的网络链路上充分利用带宽。
2. 降低网络链路上的 buffer 占用率，从而降低延迟

+ 既然不容易区分拥塞丢包和错误丢包，TCP BBR 就干脆不考虑丢包。
+ 既然灌满水管的方式容易造成缓冲区膨胀，TCP BBR 就分别估计带宽和延迟，而不是直接估计水管的容积。

## 糊涂窗口综合症SWS
基于TCP滑动窗口系统没有为可传输段设置最小长度。在某些场合这可能导致一种发送很多小的、低效率的段而不是比较少的较长段的情形，
称为糊涂窗口综合症。它的发生可能是某个接收方通告了过小窗口长度的结果，也可能是某个传输方在立即发送很少量的数据过于积极的结果

解决方法：
+ 接收端：限制接收端不能把窗口右边界移动一个太小的量，通常取MSS的值或缓存长度的一半
+ 发送端：Nagle算法

## TCP初始化序号ISN
TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。

RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。

ISN = M + F(localhost, localport, remotehost, remoteport).
+ M是一个计时器，这个计时器每隔4毫秒加1。
+ F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用MD5算法是一个比较好的选择。

## SYN Flood
在TCP三次握手时，服务器接受客户端SYN请求，操作系统为该请求分配一个TCB(传输控制块)，服务器返回一个SYN/ACK请求，并将处于SYN_RCVD状态(半开连接状态)

如果恶意地向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的资源，这就是SYN Flood攻击，也是Dos(拒绝服务攻击)与DDos(分布式拒绝服务攻击)的方式之一

### 防御措施
1. 使用TCP Wrapper(例如ssh有连接请求，守护进程tcpd会截获请求，先读取系统管理员设置的访问控制文件，符合要求传给ssh进程，不符合则中断连接)，服务端只处理有限来源IP的TCP连接请求
2. 缩短SYN Timeout时间
3. 设置SYN Cookie，给每个请求连接的IP地址分配一个Cookie，如果短时间内连接连续接受到某个IP的重复SYN报文，就认定受到攻击，以后该IP地址来的包一概丢弃
4. 使用SYN Proxy防火墙

## DNS使用TCP还是UDP
使用UDP响应时间短，TCP连接时间耗时，可能还会有多级域名服务器的迭代查询

使用UDP的缺点：因为历史原因，基于UDP传输的DNS为了限制报文不超过512字节，一旦查询应答超过512字节会被截断。
这时候就只能用TCP了

并不是UDP没办法传输超过512字节的数据，因为DNS没有字段来标识报文ID，所以默认只有一个报文，剩下的数据就被丢弃
