# 腾讯OMG团队(实习)
## 1. 画出tcp头部的协议格式
![](https://github.com/liu-jianhao/note/blob/master/Interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E9%A6%96%E9%83%A8.png)

## 2. HTTP的报文头部
### 请求报文：它会向Web服务器请求一个动作
请求报文的格式：
+ 起始行：  `<method> <request-URL> <version>`
+ 头部：    `<headers>`
+ 主体：    `<entity-body>`

 
### 响应报文：它会将请求的结果返回给客户端。
响应报文的格式：
+ 起始行：  `<version> <status> <reason-phrase>`
+ 头部：    `<headers>`
+ 主体：    `<entity-body>`

## 从浏览器输入网址到显示页面的过程？
1. 浏览器向DNS服务器查询URL对应的IP地址
2. DNS返回IP地址
3. 浏览器打开TCP连接(默认为80)，并向Web服务器发送HTTP请求
4. 若页面发生跳转，服务器则以一个重定向响应，然后转到5，否则直接转到6
5. 浏览器跟随重定向，再次发送HTTP请求
6. 浏览器处理请求， 并发回HTML响应
7. 浏览器接受请求的页面源码
8. 浏览器开始渲染HTML
9. 浏览器发送嵌入到HTML中的对象请求
10. 浏览器进一步发送异步(Ajax)请求
11. 浏览器关闭TCP连接


## TIME_WAIT
完成主动关闭后，TCP结点接收到了FIN报文。这表示对端执行了一个被动关闭。
此时这个TCP结点将在TIME_WAIT状态中等待一段固定时间
+ 确保TCP连接可靠地终止
+ 为了确保任何老的报文在重新建立同样的连接之前在网络中超时消失

### SO_REUSEADDR套接字选项
避免TCP服务重启，尝试将套接字绑定到当前已经同TCP结点相关联的端口上时出现的EADDRINUSE错误

## CLOSE_WAIT
TCP结点从对端收到FIN报文后将处于CLOSE_WAIT状态


## 什么是CDN(内容分发网络)?


## TCP的紧急指针？
占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 

当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。

因此，紧急指针指出了紧急数据的末尾在报文段中的位置。

## TCP粘包问题？
TCP通信机制的底层的粘包和拆包：当我们在接收消息的时候，显示不能认为读取到的报文就是个整包消息。如何区分一个整包消息，通常有如下五种做法：
1. 固定长度，例如每xxx 个字节代表一个整包消息，不足的前面补位。解码器在处理这类定常消息的时候比较简单，每次读到指定长度的字节后再进行解码；
2. 通过回车换行符区分消息，例如HTTP协议。这类区分消息的方式多用于文本协议；
3. 通过特定的分隔符区分整包消息；
4. 通过在协议头/消息头中设置长度字段来标识整包消息
5. 通过协议号来确定解析协议的长度，由一个唯一协议标记就可以确定一个反序列化类，从而实现区分整包

## TCP的可靠性
1. 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变。
由TCP传递给IP的信息单位称为报文段或段
2. 当TCP发送一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
3. 当TCP收到发自TCP连接另一端的数据，它将发送一个确认
4. TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。
如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段
5. TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP将对收到的数据进行重新排序，
将收到的数据以正确的顺序交给应用层。
6. 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据
7. TCP还提供流量控制


## TCP要点
### 序号
TCP提供有序的传输，所以每个数据段都要标上一个序号。一个Seq号的大小是根据上一个数据段的Seq号和长度相加而来。
注意这个长度不包括TCP头

### 发送限制
发送方要知道接收方的接收窗口和网络这两个限制因素哪一个更严格

### 发送窗口和MSS有什么关系
发送窗口决定了一口气能发多少个字节，而MSS决定了这些字节要分多少个包发完

### TCP Window Scale
由于TCP头中只给接收窗口值留了16bit(最大为65535)，Window Scale(TCP中的一个选项)的作用是向对方声明一个Shift count，
把它作为2的指数，在乘以TCP头中定义的接收窗口，就得到TCP接收窗口了

### 发送方要怎么避免拥塞？
发送方维护一个虚拟的拥塞窗口，通过以下算法尽可能接近拥塞点：
1. 连接刚建立时，发送方要把拥塞窗口的初始值定的很小，RFC建议是2个、3个或4个MSS
2. 如果发出去的包得到确认，表明没有达到拥塞点，可以增大拥塞窗口。
所以RFC建议的算法是每收到n个确认，可以把拥塞窗口增加n个MSS，这称为慢启动过程
3. 慢启动过程一段时间后，拥塞窗口达到一个较大的值。这时候不能再采用翻倍的慢启动算法，
RFC建议的算法是在每个往返时间增加1个MSS，例如发了16个MSS之后全部被确认，拥塞窗口就增加到17个MSS...
从慢启动过渡到拥塞避免的临界窗口值很有讲究。如果之前发生过拥塞，就把该拥塞点作为参考依据。
如果从来没有过拥塞就可以取一个较大的值，比如和最大接受窗口值相等

### 拥塞之后呢？
假如一段时间后没有收到确认，就认定包已经丢失了，只能重传了，这个过程称为超时重传
从发送原始包到重传该包的这段时间称为RTO(通过某个公式算出来)

重传之后的拥塞窗口该怎么调整？RFC建议把拥塞窗口降到1个MSS，然后再次进入慢启动过程。
这时临界窗口值就有参考依据了，RFC5681认为定为发生拥塞时没被确认的数据量的1/2，但不能小于2个MSS。
比如发了19个包出去，但只有3个包收到确认，那么临界窗口值就被定为16个包携带的数据量的1/2

超时重传会对性能有严重的影响，原因之一就是RTO阶段不能传数据，相当于浪费了一段时间；原因之二是拥塞窗口急剧减小

如果发生丢包，当后续的包到达接收方时，接收方会发现其Seq比期望的大，所以它每收到一个包就Ack一次期望的Seq号，提醒发送放重传
当发送方收到3个重复确认时，就意识到相应的包已经丢了，从而立即重传它，称为快速重传

如果在拥塞避免阶段发生了快速重传，是否需要像快速重传那样处理拥塞窗口？没必要。既然后续的包都到达了，说明网络并不拥塞
RFC5681建议临界窗口值应该设为发生拥塞时还没被确认的数据量的1/2，然后将拥塞窗口设置为临界窗口值增加3个MSS，
继续保留在拥塞避免阶段，这个过程称为快速恢复

如果丢的包不止一个？比如2号和3号包丢失，1、4、5、6、7、8号都到达了接收方并触发Ack2。
对于发送方来说只能通过Ack2知道2号包丢失了，但并不知道还有哪些包丢失了，接下来该怎么传？
+ 方案一：全部重传，早期TCP就是这样处理的
+ 方案二：接收方收到重传过来的2号包之后，会回复一个Ack3，因此发送方推理出3号包也丢了，重传3号包，
接收方收到后就可回复Ack9，从此发送方就可以传新的包。这个方案称为NewReno，缺点是当丢失包多的时候会花费多个RTT时间重传
+ 方案三：接收方在Ack2号包的时候，顺便把接收到的包号也告诉发送方，所以这些Ack包应该是这样：
SACK=4-8和Ack=2，这样发送方就知道缺失了2-3号包，者纷纷方案称为SACK(TCP选项)


### 总结
+ 没有拥塞时，发送窗口越大性能越好，所以在带宽没有限制的条件下，应该尽量增大接受窗口，比如启用Scale Option
+ 超时重传对性能影响最大，因为它有一段时间RTO没有传输任何数据，而且拥塞窗口会被设成1个MSS，所以要尽量避免超时重传
+ 快速重传对性能影响小一些，因为它没有等待时间，而且拥塞窗口减小的幅度没那么大
+ SACK和NewReno有利于提高重传效率，提高传输性能

