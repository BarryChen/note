

## fork()流程
对父进程程序段、数据段、堆段以及栈段创建拷贝。

如果简单地将父进程虚拟内存页拷贝到新的子进程，这样很容易造成浪费(如fork之后exec)。
采用两种技术避免这种浪费：
1. 内核将每一进程的代码段标记为只读，从而使进程无法修改自身代码。这样父子进程就可以共享同意代码段
2. 对于父进程数据段、堆段和栈段中的各页，内核采用写时复制技术来处理。
fork()之后，内核会捕获所有父进程或子进程针对这些页面的修改企图，并为将要修改的页面创建拷贝。
系统将新的页面拷贝分配给遭到内核捕获的进程，还或对子进程的相应页表项做适当调整

## vfork、clone与fork的区别
三个函数最终由同一个函数实现(kernel/fork.c中的do_fork())

vfork是为子进程立刻执行exec而专门设计的

区别：
+ 无需为子进程复制虚拟内存页或页表，子进程共享父进程的内存，直至成功执行了exec()或是调用_exit()退出
+ 在子进程调用exec()或_exit()之前，将暂停执行父进程
在不影响父进程的前提下，子进程能在vfork和exec之间做的操作屈指可数，包括对打开文件描述符进行操作

clone也能创建一个新进程，对创建进程期间的步骤控制更为精确

## 僵尸进程
在父进程执行wait()之前，其子进程就已经终止。内核通过将子进程转化为僵尸进程来处理这种情况。
这意味着将释放进程所把持的大部分资源，以便提供其他进程重新使用。
该进程所唯一保留的是内核进程表中的一条记录，其中包含了子进程ID终止状态、资源使用数据等信息

如果存在大量僵尸进程，将会填满内核进程表，从而阻碍新进程的创建。既然无法用信号杀死僵尸进程，
那么从系统中移除的唯一办法是杀掉它们的父进程，此时init进程将会接管和等待这些僵尸进程，从而从系统将它们清理掉。

## SIGCHLD信号
无论一个子进程于何时终止，系统都会向其父进程发送SIGCHILD信号，对该信号的默认处理是忽略。

子进程的终止属于异步事件，父进程应使用wait来防止僵尸进程的累积，或者采用以下两种办法：
+ 父进程调用不带WNOHANG标志的wait()，或waitpid()方法，此时如果尚无已经终止的子进程，那么调用将会阻塞
+ 父进程周期性地调用调用WHOHANG标志的waitpid()，执行针对已经终止子进程的非阻塞检查
这两种办法都使用便，可以采用针对SIGCHLD信号的处理程序，用来捕获终止子进程。

进程可以将对SIGCHLD信号的处理设置置为忽略(SIG_IGN)，这将立即丢弃终止子进程的状态。


## epoll & poll & select
select的缺点：
1. 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
2. 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销很多时也很大
3. select支持的文件描述符数量太小，默认是1024

epoll避免了上述三个缺点：
1. 每次注册新的事件到epoll句柄中时(epoll_ctl中指定EPOLL_CTL_ADD)，会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程只会拷贝一次
2. 不像select或poll一样每次都把current(当前进程)轮流加入fd对应的设备等带队列中，而只在epoll_ctl时把current挂一遍并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd
3. epoll所支持的fd上限就是可以最大打开文件的数目

## epoll的ET和LT
水平触发：如果文件描述符上可以非阻塞地执行IO系统调用，此时认为它已经就绪了
边缘触发：如果文件描述符自上次状态检查以来有了新的IO活动，此时需要触发通知

采用水平触发时，可以在任意时刻检查文件描述符的就绪状态，
而采用边缘触发时，只有当IO事件发生时我们才会收到通知，
所以在接收到一个IO事件通知后，要尽可能多地执行IO

## ET使用非阻塞socket
如果程序采用循环来对文件描述符执行尽可能多的IO，而文件描述符又被置为可阻塞的，
那么最终当没有更多的IO可执行时，IO系统调用就会阻塞，所以每个被检查的文件描述符应该是非阻塞的

## 进程与线程的区别？
+ 进程是资源分配的最小单位，线程是程序执行的最小单位。

+ 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

+ 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。

+ 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。


## 惊群效应
### accept惊群（Linux2.6已解决）
一个连接过来，只有一个进程可以accept成功
### epoll惊群
如果多个进程/线程阻塞在监听同一个监听socket fd的epoll_wait上，当有一个新的连接到来时，所有的进程都会被唤醒。