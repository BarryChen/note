# 腾讯OMG团队(实习)
## 3. 数组和指针的区别
1. 数组本身体现出来的就是一个 指针常量的 “特性”，即不能对数组的首地址进行修改，内存上的地址就已经是确定了的。而指针本身是一个变量，他指向了一个地址，这个是可以变化的，也就说他可以重新赋值指向新的地址；
2. 当调用sizeof函数时，对于数组，得到的是数组元素个数*数据类型的大小，而对于指针，得到的是指针类型的大小，这个取决于机器的位数，比如32位机，对应的指针就是4字节的大小；
3. 指针相比数组更加灵活。

4. 相同之处：比如当作为形参的时候，定义成 指针还是数组都是一样的，因为这个时候传入的都是数组的首地址，也就是这个数组名，反映出来的就等于是一个指针。

## 4. c++种struct和class的区别
1. 如果不申明访问权限，class的默认权限是private，而struct是public
2. 对于继承，如果也没有明确是public继承还是private继承或者是protected继承，class
默认是private的继承，而struct是public继承。
3. 从抽象上来说，class更像是对象的实现体，而struct更像是数据结构的实现体。

## 5. 构造函数能不能是虚函数？
不能，因为类对象中占前4个字节的虚表指针 需要在构造函数完成之后才会生成，通过 虚表指针才能找到虚函数表，访问调用对应的虚函数。如果构造函数是虚函数，那么就只能通过虚表指针才能访问到，关键是此时就需要让构造函数产生出虚表指针。陷入了先有蛋还是现有鸡的问题

## 6. 析构函数可不可以是虚函数？
可以，而且如果说这个类不是final的，也就是说他是某一个类的父类，那么该类的析构函数必须是虚函数，因为如果不是虚函数，那么其子类对象的父类组成部分将无法得到释放，造成资源泄露。

## 7. 析构函数可不可以是纯虚函数？
我觉得不建议是，因为我们知道纯虚函数是没有实现体的，那么子类对象在析构的时候，父类组成部分就没办法释放，显然不行。但是对于大部分编译器来说，可以将析构函数申明为纯虚函数，然后在类外写纯虚函数的实现体，从语法上不会报错。

## 8. 举例一种STL中的容器
比如vector（当时答得是这个），vector的的实现其实就是封装了一个动态数组，里面有3个内部迭代器，分别是start、finnish、end_of_storage。如果通过push_back或者insert插入元素造成超过容量，此时容量会扩展至2倍，这个过程分为：重新配置、移动拷贝元素、释放原空间，这3个大部，支持随机访问等

## 9. 举例STL的一种算法
比如find、accumulate、next_permutation、unique、position等等

## 10. 如何防止c++头文件被重复引用
可以使用ifndef或者program once，都可以。但是两者有一些区别。

从兼容性上说，ifndef更好，有些老的编译器可能不支持program once；

此外，对于2个名字不同的头文件，但内容相同，ifndef还是可以鉴别出来，防止重复，program once 不行。

## 11. 内联函数和宏的区别
内联函数的展开发生在编译期，而宏是在预处理阶段；

内联函数本身是函数，而宏不是；

最重要的一点：内联函数会对参数进行类型检查，而宏只是简单的替换，所以内联函数更加安全，所以往往宏需要对参数加括号，但是也不一定安全， 内联函数有自己明确的作用域或者访问权限，比如放在类里面的private，而宏是没有的。

定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。

## 12. 内联函数和普通函数的区别？
我们知道普通函数在被调用时，系统首先要跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一个拷贝；

内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N处调用了此内联函数，则此函数就会有N个代码段的拷贝。

从内联函数的调用来看，它因为少了一个寻址过程而提高了代码的执行效率，但是这是以空间的代价来换取的。


## static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。


## 容器删除元素的方法
+ vector、string、deque，使用erase-remove
+ list，使用list::remove
+ 关联容器，使用erase成员函数

## 可重入函数
可重入函数也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，

其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，

可以允许有多个该函数的副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。

如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价


## 