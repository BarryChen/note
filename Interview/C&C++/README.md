## 数组和指针的区别
1. 数组本身体现出来的就是一个 指针常量的 “特性”，即不能对数组的首地址进行修改，内存上的地址就已经是确定了的。而指针本身是一个变量，他指向了一个地址，这个是可以变化的，也就说他可以重新赋值指向新的地址；
2. 当调用sizeof函数时，对于数组，得到的是数组元素个数*数据类型的大小，而对于指针，得到的是指针类型的大小，这个取决于机器的位数，比如32位机，对应的指针就是4字节的大小；
3. 指针相比数组更加灵活。

4. 相同之处：比如当作为形参的时候，定义成 指针还是数组都是一样的，因为这个时候传入的都是数组的首地址，也就是这个数组名，反映出来的就等于是一个指针。

## c++种struct和class的区别
1. 如果不申明访问权限，class的默认权限是private，而struct是public
2. 对于继承，如果也没有明确是public继承还是private继承或者是protected继承，class
默认是private的继承，而struct是public继承。
3. 从抽象上来说，class更像是对象的实现体，而struct更像是数据结构的实现体。

## 构造函数能不能是虚函数？
不能，因为类对象中占前4个字节的虚表指针 需要在构造函数完成之后才会生成，通过 虚表指针才能找到虚函数表，访问调用对应的虚函数。如果构造函数是虚函数，那么就只能通过虚表指针才能访问到，关键是此时就需要让构造函数产生出虚表指针。陷入了先有蛋还是现有鸡的问题

## 析构函数可不可以是虚函数？
可以，而且如果说这个类不是final的，也就是说他是某一个类的父类，那么该类的析构函数必须是虚函数，因为如果不是虚函数，那么其子类对象的父类组成部分将无法得到释放，造成资源泄露。

## 析构函数可不可以是纯虚函数？
我觉得不建议是，因为我们知道纯虚函数是没有实现体的，那么子类对象在析构的时候，父类组成部分就没办法释放，显然不行。但是对于大部分编译器来说，可以将析构函数申明为纯虚函数，然后在类外写纯虚函数的实现体，从语法上不会报错。

## 举例一种STL中的容器
比如vector（当时答得是这个），vector的的实现其实就是封装了一个动态数组，里面有3个内部迭代器，分别是start、finnish、end_of_storage。如果通过push_back或者insert插入元素造成超过容量，此时容量会扩展至2倍，这个过程分为：重新配置、移动拷贝元素、释放原空间，这3个大部，支持随机访问等

## 举例STL的一种算法
比如find、accumulate、next_permutation、unique、position等等

## 如何防止c++头文件被重复引用
可以使用ifndef或者program once，都可以。但是两者有一些区别。

从兼容性上说，ifndef更好，有些老的编译器可能不支持program once；

此外，对于2个名字不同的头文件，但内容相同，ifndef还是可以鉴别出来，防止重复，program once 不行。

## 内联函数和宏的区别
内联函数的展开发生在编译期，而宏是在预处理阶段；

内联函数本身是函数，而宏不是；

最重要的一点：内联函数会对参数进行类型检查，而宏只是简单的替换，所以内联函数更加安全，所以往往宏需要对参数加括号，但是也不一定安全， 内联函数有自己明确的作用域或者访问权限，比如放在类里面的private，而宏是没有的。

定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。

## 内联函数和普通函数的区别？
我们知道普通函数在被调用时，系统首先要跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一个拷贝；

内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N处调用了此内联函数，则此函数就会有N个代码段的拷贝。

从内联函数的调用来看，它因为少了一个寻址过程而提高了代码的执行效率，但是这是以空间的代价来换取的。


## static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。


## 容器删除元素的方法
+ vector、string、deque，使用erase-remove
+ list，使用list::remove
+ 关联容器，使用erase成员函数

## 可重入函数
可重入函数也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，

其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，

可以允许有多个该函数的副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。

如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价


## C文件编译连接过程
1. 预处理：main.c -> main.i (一个ASCII码的中间文件)
    + gcc -E main.c -o main.i
    + 预处理主要处理源代码文件中的以"#"开始的预编译指令
    + 如展开所有宏定义(#define)，处理所条件编译指令(#if、#ifdef、#else...)，处理“#define”预编译指令，
    将被包含的文件插入到该预编译指令的位置，删除所有注释
2. 编译： main.i -> main.s （汇编文件）
    + gcc -S main.i -o main.s
    + 把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件
3. 汇编： main.s -> main.o （可重定位的目标文件）
    + as main.s -o main.o 或者 gcc -c main.s -o main.o
    + 汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令
    + 汇编器只是根据汇编指令和机器指令的对照表一一翻译就可以了
4. 链接： main.o -> prog （可执行目标文件）
    + 链接过程主要包括了地址和空间分配、符号决议、和重定位等

## 目标文件里有什么
### ELF文件类型
+ 可重定位文件
    + 这类文件包含代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类
    + Linux的.o文件和Windows的.obj文件
+ 可执行文件
    + 这类文件包含了可以直接执行的程序
+ 共享目标文件
    + 这种文件包含代码和数据，可以在以下两种情况下使用
        + 一种是连接器可以使用这种文件跟其他可重定向文件和共享目录文件链接，产生新的目标文件
        + 第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行
    + Linux的.so文件，如/lib/glibc-2.5.so，Windows的DLL
+ 核心转储文件
    + 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件

### 目标文件长什么样
目标文件除了有编译后的机器指令代码、数据，还有链接时必须的如符号表、调试信息、字符串等，目标文件将这些信息按不同的属性以“节”的形式存储，或称为段。

+ ELF头部
    + 包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号程序入口地址、段表的位置和长度等

+ .text：代码段
    + 编译后的机器指令
+ .data：数据段
    + 全局变量和局部静态变量数据
+ .bss：
    + 未初始化的全局变量和局部静态变量
    + 只是预留位置，不占空间
+ .rodata：只读数据段
    + 存放只读数据，如const修饰的变量和字符串常量
    + 单独设立.rodata段可以保证程序的安全性，加载时将.rodata段映射成只读

+ 段表(Section Header Table)
    + 该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他信息

### 为什么要分为代码段和数据段
+ 当程序被装载后，数据和指令分别被映射到两个虚拟区域，数据区域是可读写的，代码区域是只读的，
这样可以防止程序的指令被有意或无意地改写
+ CPU的缓存命中率很重要。指令和数据的分离有利于提高程序的局部性，现代CPU的缓存一般都被设计为数据缓存和指令缓存，
这样有利于提高命中率
+ 当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份改程序的指令部分，
对于其他只读数据也一样，是属于可以共享的。而每个副本进程的数据区域是不一样的，它们是进程私有的

### 重定位表
链接器需要对目标文件中那些对绝对地址的引用的位置进行重定位，对于每个需要重定位的代码段或数据段都会有一个对应的重定位表。

例如".rel.text"段就是针对".text"段的重定位表

### 链接的接口——符号
每一个目标文件都有一个符号表，里面记录了目标文件中所用到的所有符号，
每个定义的符号都有一个对应的值，叫做符号值，对于变量和函数来说，符号之就是他们的地址

分类：
+ 定义在本目标文件的全局符号，可以被其他目标文件引用
+ 在本目标文件中引用的全局符号，却没有定义在本目标文件，叫做外部符号，如“printf”
+ 段名，由编译器生成，它的值就是该段的起始值
+ 局部符号
+ 行号信息
我们只关注前面两个全局符号，因为这是链接过程关心的，其它的符号对于其它目标文件来说是不可见的

符号表在文件中是一个段：“.symtab”

### 特殊符号
链接器链接生产可执行文件时，它会为我们定义很多特殊符号，如：
+ __excutable_start，程序的起始地址，注意不是入口地址，时程序最开始的地址
+ __etext 或 _etext 或 etext，代码段结束地址
+ _edata 或 edata，数据段结束地址
+ _end 或 end，程序结束地址


### 符号修饰和函数签名
为防止符号名冲突，C源代码文件中的所有全局的变量和函数经过编译后，先对应的符号名前加上下划线，
Windows平台下的编译器仍这样做，Linux下的gcc已经不这样做了

C++则增加了名称空间的概念

#### C++符号修饰(符号改编)
gcc的基本C++名称修饰方法：
+ 所有符号都"_Z"开头，对于名称空间或类里面的名字，后面紧跟"N"，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，
再以"E"结尾
+ 对于一个函数来说，它的参数列表紧跟在"E"的后面，对于int类型来说，就是"i"
+ 例如：`int C::C2::func(int)` -> `_ZN1C2C24funcEi`
+ 不同的编译器的名称修饰方法不同

#### extern "C"
C++编译器会把在extern "C"的大括号内部的代码当做C语言代码处理

有时候有些头文件声明了一些C语言的函数和全局变量，这个头文件可能会被C语言代码或则C++语言代码包含

例如string.h中的memset函数，在C++语言中，编译器会认为这个函数是C++函数，将memset的符号秀事成_Z6memsetPvii，
这样链接器就无法与C语言库中的memset符号进行链接，因此必须使用extern "C"来声明这个memset函数，
但C语言不支持extern "C"语法，这样就需要定义两个头文件

解决办法是使用C++的宏"__cplusplus"，C++编译器会在编译C++程序时默认定义这个宏，在头文件就可以使用条件判断宏

#### 强符号与弱符号
函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号

+ 规则一：不允许请符号被多次定义
+ 规则二：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号
+ 规则三：如果一个符号在所有目标文件中都是弱符号，选择占用空间最大的

#### 强引用与弱引用
在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议，如果未定义，则对该引用不报错，运行会有运行错误

## 没有main函数
程序的真正入口是_start函数，实际上main函数只是用户代码的入口,它会由系统库去调用,在main函数之前,系统库会做一些初始化工作,比如分配全局变量的内存,初始化堆、线程等,当main函数执行完后,会通过exit()函数做一些清理工作,用户可以自己实现_start函数：
```c
#include <stdio.h> 
#include <stdlib.h> 
_start(void) { 
    printf("hello world!/n"); 
    exit(0); 
}
```
执行如下编译命令并运行:
```shell
$ gcc hello_start.c -nostartfiles -o hello_start
$ ./hello_start 
hello world! 
```
这里的 **-nostartfiles** 的功能是Do notuse the standard system startup files when linking,也就是不使用标准的startupfiles,但是还是会链接系统库,所以程序还是可以执行的

也可以自己指定入口函数：
```c
#include <stdio.h> 
#include <stdlib.h> 
int nomain(){
    printf("helloworld!/n"); 
    exit(0); 
} 
```
采用如下命令编译 
```shell
$ gcc hello_nomain.c -nostartfiles -e nomain -o hello_nomain  
```
其中-e选项可以指定程序入口符号， 对比hello_start的符号表发现只是将_start换成了nomain


## 快排优化
1. 对于小数组而言， 快速排序比插入排序要慢， 所以在排序小数组时应该切换到插入排序，一般来说， 5到15间的任意值在多数情况下都能令人满意
2. 三数取中法： 分别取出数组的最左端元素，最右端元素和中间元素， 在这三个数中取出中位数，作为基准元素

## memmove和memcopy
他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。

## 排序算法
![](https://img-blog.csdnimg.cn/20190420172243819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)


## C++内存管理
+ 静态区：保存自动全局变量和static变量（包括static全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，有编译器在编译的时候分配（数据段（存储全局数据和静态数据）和代码段（可执行的代码/只读常量））。
+ 栈：保存局部变量。栈上的内容只在函数范围内存在，当函数运行结束的时候，这些内容也会自动销毁。其特点是效率高但是空间大小有限。
+ 堆：由malloc系列函数或者new操作符分配的内存。其生命周期由free和delete决定。在没有释放之前一直存在，直到函数结束。其特点是使用灵活，空间比较大，但容易出错。


## inline 与 性能
函数调用的开销： 参数压栈、栈帧开辟与销毁、寄存器保存与恢复等

如果函数本身的代码量较小，比函数调用时做的准备工作的代码还小，这时候内联肯定性能较好

由于内联后函数体执行的代码是相邻的，其执行的代码都在同一页面或连续的页面中，如果没有内联，执行到被调用函数时，
需要跳到含有被调用函数的页面执行，而被调用函数所使用的页面很可能不在高速缓存中。也就是说，内联可以使缺页率降低，
速度更快


## 什么时候不需要使用智能指针
+ 指针并不拥有该数据，例如传参或者明确的引用，生命期短于拥有者的用raw ptr
+ 在代码中涉及跟踪一块内存的所有权，分配或取消分配; 智能指针通常可以明确执行这些操作的需要。