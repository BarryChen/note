## 数组和指针的区别
1. 数组本身体现出来的就是一个 指针常量的 “特性”，即不能对数组的首地址进行修改，内存上的地址就已经是确定了的。而指针本身是一个变量，他指向了一个地址，这个是可以变化的，也就说他可以重新赋值指向新的地址；
2. 当调用sizeof函数时，对于数组，得到的是数组元素个数*数据类型的大小，而对于指针，得到的是指针类型的大小，这个取决于机器的位数，比如32位机，对应的指针就是4字节的大小；
3. 指针相比数组更加灵活。

4. 相同之处：比如当作为形参的时候，定义成 指针还是数组都是一样的，因为这个时候传入的都是数组的首地址，也就是这个数组名，反映出来的就等于是一个指针。

## c++种struct和class的区别
1. 如果不申明访问权限，class的默认权限是private，而struct是public
2. 对于继承，如果也没有明确是public继承还是private继承或者是protected继承，class
默认是private的继承，而struct是public继承。
3. 从抽象上来说，class更像是对象的实现体，而struct更像是数据结构的实现体。

## 构造函数能不能是虚函数？
不能，因为类对象中占前4个字节的虚表指针 需要在构造函数完成之后才会生成，通过 虚表指针才能找到虚函数表，访问调用对应的虚函数。如果构造函数是虚函数，那么就只能通过虚表指针才能访问到，关键是此时就需要让构造函数产生出虚表指针。陷入了先有蛋还是现有鸡的问题

## 析构函数可不可以是虚函数？
可以，而且如果说这个类不是final的，也就是说他是某一个类的父类，那么该类的析构函数必须是虚函数，因为如果不是虚函数，那么其子类对象的父类组成部分将无法得到释放，造成资源泄露。

## 析构函数可不可以是纯虚函数？
我觉得不建议是，因为我们知道纯虚函数是没有实现体的，那么子类对象在析构的时候，父类组成部分就没办法释放，显然不行。但是对于大部分编译器来说，可以将析构函数申明为纯虚函数，然后在类外写纯虚函数的实现体，从语法上不会报错。

## 举例一种STL中的容器
比如vector（当时答得是这个），vector的的实现其实就是封装了一个动态数组，里面有3个内部迭代器，分别是start、finnish、end_of_storage。如果通过push_back或者insert插入元素造成超过容量，此时容量会扩展至2倍，这个过程分为：重新配置、移动拷贝元素、释放原空间，这3个大部，支持随机访问等

## 举例STL的一种算法
比如find、accumulate、next_permutation、unique、position等等

## 如何防止c++头文件被重复引用
可以使用ifndef或者program once，都可以。但是两者有一些区别。

从兼容性上说，ifndef更好，有些老的编译器可能不支持program once；

此外，对于2个名字不同的头文件，但内容相同，ifndef还是可以鉴别出来，防止重复，program once 不行。

## 内联函数和宏的区别
内联函数的展开发生在编译期，而宏是在预处理阶段；

内联函数本身是函数，而宏不是；

最重要的一点：内联函数会对参数进行类型检查，而宏只是简单的替换，所以内联函数更加安全，所以往往宏需要对参数加括号，但是也不一定安全， 内联函数有自己明确的作用域或者访问权限，比如放在类里面的private，而宏是没有的。

定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。

## 内联函数和普通函数的区别？
我们知道普通函数在被调用时，系统首先要跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一个拷贝；

内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N处调用了此内联函数，则此函数就会有N个代码段的拷贝。

从内联函数的调用来看，它因为少了一个寻址过程而提高了代码的执行效率，但是这是以空间的代价来换取的。


## static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。


## 容器删除元素的方法
+ vector、string、deque，使用erase-remove
+ list，使用list::remove
+ 关联容器，使用erase成员函数

## 可重入函数
可重入函数也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，

其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，

可以允许有多个该函数的副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。

如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价


## C文件编译连接过程
1. 预处理：main.c -> main.i (一个ASCII码的中间文件)
2. 编译： main.i -> main.s （汇编文件）
3. 汇编： main.s -> main.o （可重定位的目标文件）
4. 链接： main.o -> prog （可执行目标文件）

## 没有main函数
程序的真正入口是_start函数，实际上main函数只是用户代码的入口,它会由系统库去调用,在main函数之前,系统库会做一些初始化工作,比如分配全局变量的内存,初始化堆、线程等,当main函数执行完后,会通过exit()函数做一些清理工作,用户可以自己实现_start函数：
```c
#include <stdio.h> 
#include <stdlib.h> 
_start(void) { 
    printf("hello world!/n"); 
    exit(0); 
}
```
执行如下编译命令并运行:
```shell
$ gcc hello_start.c -nostartfiles -o hello_start
$ ./hello_start 
hello world! 
```
这里的 **-nostartfiles** 的功能是Do notuse the standard system startup files when linking,也就是不使用标准的startupfiles,但是还是会链接系统库,所以程序还是可以执行的

也可以自己指定入口函数：
```c
#include <stdio.h> 
#include <stdlib.h> 
int nomain(){
    printf("helloworld!/n"); 
    exit(0); 
} 
```
采用如下命令编译 
```shell
$ gcc hello_nomain.c -nostartfiles -e nomain -o hello_nomain  
```
其中-e选项可以指定程序入口符号， 对比hello_start的符号表发现只是将_start换成了nomain


## 快排优化
1. 对于小数组而言， 快速排序比插入排序要慢， 所以在排序小数组时应该切换到插入排序，一般来说， 5到15间的任意值在多数情况下都能令人满意
2. 三数取中法： 分别取出数组的最左端元素，最右端元素和中间元素， 在这三个数中取出中位数，作为基准元素

## memmove和memcopy
他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。

## 排序算法
![](https://img-blog.csdnimg.cn/20190420172243819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)


## C++内存管理
+ 静态区：保存自动全局变量和static变量（包括static全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，有编译器在编译的时候分配（数据段（存储全局数据和静态数据）和代码段（可执行的代码/只读常量））。
+ 栈：保存局部变量。栈上的内容只在函数范围内存在，当函数运行结束的时候，这些内容也会自动销毁。其特点是效率高但是空间大小有限。
+ 堆：由malloc系列函数或者new操作符分配的内存。其生命周期由free和delete决定。在没有释放之前一直存在，直到函数结束。其特点是使用灵活，空间比较大，但容易出错。


## inline 与 性能
函数调用的开销： 参数压栈、栈帧开辟与销毁、寄存器保存与恢复等

如果函数本身的代码量较小，比函数调用时做的准备工作的代码还小，这时候内联肯定性能较好

由于内联后函数体执行的代码是相邻的，其执行的代码都在同一页面或连续的页面中，如果没有内联，执行到被调用函数时，
需要跳到含有被调用函数的页面执行，而被调用函数所使用的页面很可能不在高速缓存中。也就是说，内联可以使缺页率降低，
速度更快


## 什么时候不需要使用智能指针
+ 传参或者明确的引用，生命期短于拥有者的用raw ptr
+ 在代码中涉及跟踪一块内存的所有权，分配或取消分配; 智能指针通常可以明确执行这些操作的需要。