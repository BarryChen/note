## 数组和指针的区别
1. 数组本身体现出来的就是一个 指针常量的 “特性”，即不能对数组的首地址进行修改，内存上的地址就已经是确定了的。而指针本身是一个变量，他指向了一个地址，这个是可以变化的，也就说他可以重新赋值指向新的地址；
2. 当调用sizeof函数时，对于数组，得到的是数组元素个数*数据类型的大小，而对于指针，得到的是指针类型的大小，这个取决于机器的位数，比如32位机，对应的指针就是4字节的大小；
3. 指针相比数组更加灵活。

4. 相同之处：比如当作为形参的时候，定义成 指针还是数组都是一样的，因为这个时候传入的都是数组的首地址，也就是这个数组名，反映出来的就等于是一个指针。

## c++种struct和class的区别
1. 如果不申明访问权限，class的默认权限是private，而struct是public
2. 对于继承，如果也没有明确是public继承还是private继承或者是protected继承，class
默认是private的继承，而struct是public继承。
3. 从抽象上来说，class更像是对象的实现体，而struct更像是数据结构的实现体。

## 构造函数能不能是虚函数？
不能，因为类对象中占前4个字节的虚表指针 需要在构造函数完成之后才会生成，通过 虚表指针才能找到虚函数表，访问调用对应的虚函数。如果构造函数是虚函数，那么就只能通过虚表指针才能访问到，关键是此时就需要让构造函数产生出虚表指针。陷入了先有蛋还是现有鸡的问题

## 析构函数可不可以是虚函数？
可以，而且如果说这个类不是final的，也就是说他是某一个类的父类，那么该类的析构函数必须是虚函数，因为如果不是虚函数，那么其子类对象的父类组成部分将无法得到释放，造成资源泄露。

## 析构函数可不可以是纯虚函数？
我觉得不建议是，因为我们知道纯虚函数是没有实现体的，那么子类对象在析构的时候，父类组成部分就没办法释放，显然不行。但是对于大部分编译器来说，可以将析构函数申明为纯虚函数，然后在类外写纯虚函数的实现体，从语法上不会报错。

## 举例一种STL中的容器
比如vector（当时答得是这个），vector的的实现其实就是封装了一个动态数组，里面有3个内部迭代器，分别是start、finnish、end_of_storage。如果通过push_back或者insert插入元素造成超过容量，此时容量会扩展至2倍，这个过程分为：重新配置、移动拷贝元素、释放原空间，这3个大部，支持随机访问等

## 举例STL的一种算法
比如find、accumulate、next_permutation、unique、position等等

## 如何防止c++头文件被重复引用
可以使用ifndef或者program once，都可以。但是两者有一些区别。

从兼容性上说，ifndef更好，有些老的编译器可能不支持program once；

此外，对于2个名字不同的头文件，但内容相同，ifndef还是可以鉴别出来，防止重复，program once 不行。

## 内联函数和宏的区别
内联函数的展开发生在编译期，而宏是在预处理阶段；

内联函数本身是函数，而宏不是；

最重要的一点：内联函数会对参数进行类型检查，而宏只是简单的替换，所以内联函数更加安全，所以往往宏需要对参数加括号，但是也不一定安全， 内联函数有自己明确的作用域或者访问权限，比如放在类里面的private，而宏是没有的。

定义在类中的成员函数缺省都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。

## 内联函数和普通函数的区别？
我们知道普通函数在被调用时，系统首先要跳跃到该函数的入口地址，执行函数体，执行完成后，再返回到函数调用的地方，函数始终只有一个拷贝；

内联函数则不需要进行一个寻址的过程，当执行到内联函数时，此函数展开（很类似宏的使用），如果在 N处调用了此内联函数，则此函数就会有N个代码段的拷贝。

从内联函数的调用来看，它因为少了一个寻址过程而提高了代码的执行效率，但是这是以空间的代价来换取的。


## static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;

static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；

static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。


## 容器删除元素的方法
+ vector、string、deque，使用erase-remove
+ list，使用list::remove
+ 关联容器，使用erase成员函数

## 可重入函数
可重入函数也可以这样理解，重入即表示重复进入，首先它意味着这个函数可以被中断，

其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，

可以允许有多个该函数的副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。

如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价


## C文件编译连接过程
1. 预处理：main.c -> main.i (一个ASCII码的中间文件)
    + gcc -E main.c -o main.i
    + 预处理主要处理源代码文件中的以"#"开始的预编译指令
    + 如展开所有宏定义(#define)，处理所条件编译指令(#if、#ifdef、#else...)，处理“#define”预编译指令，
    将被包含的文件插入到该预编译指令的位置，删除所有注释
2. 编译： main.i -> main.s （汇编文件）
    + gcc -S main.i -o main.s
    + 把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件
3. 汇编： main.s -> main.o （可重定位的目标文件）
    + as main.s -o main.o 或者 gcc -c main.s -o main.o
    + 汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令
    + 汇编器只是根据汇编指令和机器指令的对照表一一翻译就可以了
4. 链接： main.o -> prog （可执行目标文件）
    + 链接过程主要包括了地址和空间分配、符号决议、和重定位等

## 目标文件里有什么
### ELF文件类型
+ 可重定位文件
    + 这类文件包含代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类
    + Linux的.o文件和Windows的.obj文件
+ 可执行文件
    + 这类文件包含了可以直接执行的程序
+ 共享目标文件
    + 这种文件包含代码和数据，可以在以下两种情况下使用
        + 一种是连接器可以使用这种文件跟其他可重定向文件和共享目录文件链接，产生新的目标文件
        + 第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行
    + Linux的.so文件，如/lib/glibc-2.5.so，Windows的DLL
+ 核心转储文件
    + 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件

### 目标文件长什么样
目标文件除了有编译后的机器指令代码、数据，还有链接时必须的如符号表、调试信息、字符串等，目标文件将这些信息按不同的属性以“节”的形式存储，或称为段。

+ ELF头部
    + 包含了描述整个文件的基本属性，比如ELF文件版本、目标机器型号程序入口地址、段表的位置和长度等

+ .text：代码段
    + 编译后的机器指令
+ .data：数据段
    + 全局变量和局部静态变量数据
+ .bss：
    + 未初始化的全局变量和局部静态变量
    + 只是预留位置，不占空间
+ .rodata：只读数据段
    + 存放只读数据，如const修饰的变量和字符串常量
    + 单独设立.rodata段可以保证程序的安全性，加载时将.rodata段映射成只读

+ 段表(Section Header Table)
    + 该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他信息

### 为什么要分为代码段和数据段
+ 当程序被装载后，数据和指令分别被映射到两个虚拟区域，数据区域是可读写的，代码区域是只读的，
这样可以防止程序的指令被有意或无意地改写
+ CPU的缓存命中率很重要。指令和数据的分离有利于提高程序的局部性，现代CPU的缓存一般都被设计为数据缓存和指令缓存，
这样有利于提高命中率
+ 当系统中运行着多个该程序的副本时，它们的指令都是一样的，所以内存中只需要保存一份改程序的指令部分，
对于其他只读数据也一样，是属于可以共享的。而每个副本进程的数据区域是不一样的，它们是进程私有的

### 重定位表
链接器需要对目标文件中那些对绝对地址的引用的位置进行重定位，对于每个需要重定位的代码段或数据段都会有一个对应的重定位表。

例如".rel.text"段就是针对".text"段的重定位表

### 链接的接口——符号
每一个目标文件都有一个符号表，里面记录了目标文件中所用到的所有符号，
每个定义的符号都有一个对应的值，叫做符号值，对于变量和函数来说，符号之就是他们的地址

分类：
+ 定义在本目标文件的全局符号，可以被其他目标文件引用
+ 在本目标文件中引用的全局符号，却没有定义在本目标文件，叫做外部符号，如“printf”
+ 段名，由编译器生成，它的值就是该段的起始值
+ 局部符号
+ 行号信息
我们只关注前面两个全局符号，因为这是链接过程关心的，其它的符号对于其它目标文件来说是不可见的

符号表在文件中是一个段：“.symtab”

### 特殊符号
链接器链接生产可执行文件时，它会为我们定义很多特殊符号，如：
+ __excutable_start，程序的起始地址，注意不是入口地址，时程序最开始的地址
+ __etext 或 _etext 或 etext，代码段结束地址
+ _edata 或 edata，数据段结束地址
+ _end 或 end，程序结束地址


### 符号修饰和函数签名
为防止符号名冲突，C源代码文件中的所有全局的变量和函数经过编译后，先对应的符号名前加上下划线，
Windows平台下的编译器仍这样做，Linux下的gcc已经不这样做了

C++则增加了名称空间的概念

#### C++符号修饰(符号改编)
gcc的基本C++名称修饰方法：
+ 所有符号都"_Z"开头，对于名称空间或类里面的名字，后面紧跟"N"，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，
再以"E"结尾
+ 对于一个函数来说，它的参数列表紧跟在"E"的后面，对于int类型来说，就是"i"
+ 例如：`int C::C2::func(int)` -> `_ZN1C2C24funcEi`
+ 不同的编译器的名称修饰方法不同

#### extern "C"
C++编译器会把在extern "C"的大括号内部的代码当做C语言代码处理

有时候有些头文件声明了一些C语言的函数和全局变量，这个头文件可能会被C语言代码或则C++语言代码包含

例如string.h中的memset函数，在C++语言中，编译器会认为这个函数是C++函数，将memset的符号秀事成_Z6memsetPvii，
这样链接器就无法与C语言库中的memset符号进行链接，因此必须使用extern "C"来声明这个memset函数，
但C语言不支持extern "C"语法，这样就需要定义两个头文件

解决办法是使用C++的宏"__cplusplus"，C++编译器会在编译C++程序时默认定义这个宏，在头文件就可以使用条件判断宏

#### 强符号与弱符号
函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号

+ 规则一：不允许请符号被多次定义
+ 规则二：如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号
+ 规则三：如果一个符号在所有目标文件中都是弱符号，选择占用空间最大的

#### 强引用与弱引用
在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议，如果未定义，则对该引用不报错，运行会有运行错误

## 静态链接
1. 空间与地址分配。扫描所有的数据目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表所有符号定义和符号引用收集起来统一放到一个全局符号表中。这一步中，链接器就能获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件各个段合并后的长度与位置，并建立映射关系
    + 链接后的程序所使用的地址已经是程序在进程中的虚拟地址，即VMA。链接之前，目标文件中的所有段的VMA都是0，因为虚拟地址空间还没有分配，链接之后才分配。
    + 符号地址：链接器只需要给每个符号加上一个偏移量

2. 符号解析与重定位。使用上一步中收集的所有信息读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等
    + 目标文件如果使用了外部符号，这些外部符号在目标文件里的地址是需要重定位的，这些指令是从之前提到的重定位表(一个或多个段)中找的(.rel.text、.rel.data)

### C++相关

#### 重复代码消除
C++编译器在很多时候回产生重复的代码，比如模板(Templates)、外部内联函数(Extern Inline Function)和虚函数表都有可能在不同的编译单元里生成相同的代码。

当一个模板在一个编译单元同时实例化成相同的类型的时候，必然会生成重复的代码，这样会有几个缺点：
1. 空间浪费
2. 地址较易出错，有可能两个指向同一个函数的指针会不相等
3. 指令运行效率较低，因为现代的CPU会对指令和数据进行缓存，如果同样一份指令有多份副本，那么指令Cache的命中率就会降低

一个有效的做法就是将每个模板的实例代码都单独地放在一个段里，每个段都只包含一个模板实例，比如有个模板函数是add<T>()，某个编译单元以int类型和float类型实例化该模板，那么该编译单元的目标文件就包含这两个该模板的实例的段，当别的编译单元也以int或float类型实例化该模板函数后，也会生成同样的名字，这样链接器在最终链接的时候可以区分这些相同的模板实例段，然后将它们合并入最后的代码段

gcc编译器将这种类似的需要在最终链接时合并的段命名为".gnu.linkonce.name"，其中"name"是该模板函数实例的修饰后名称

visual C++编译器将这种类型的段称为"COMDAT"

对于外部内联函数和虚函数表的做法也类似，比如对于一个有虚函数的类来说，有一个与之对应的虚函数表，编译器会在用到这个类的多个编译单元生成虚函数表，造成代码重复：外部内联函数、默构造函数、默认拷贝构造函数和赋值操作符也有类似的问题，它们的解决办法基本跟模板的重复代码消除类似

还存在一个问题：比如相同名称的段可能拥有不同的内容，这可能由于不同的编译单元使用了不同的编译器版本或者编译优化选项，导致同一个函数编译出来的实际代码有所不同，那么这种情况链接器可能会做出一个选择，那就是随意选择其中任何一个副本作为链接的输入，然后同时提供一个警告信息

函数级别链接：让所有函数都单独保存到一个段里，当链接器需要某个函数时，它就将它合并到输出文件中，对于那些没有用的函数则将它们抛弃。可以减少空间浪费，但会减慢编译和链接过程，因为链接器需要计算各个函数之间的依赖关系。gcc："-ffunction-sections"、"-fdata-sections"，这两个选项的作用就是将每个函数或变量分别保持到独立的段中

## 动态链接
### 为什么需要动态链接
+ 静态链接浪费空间
+ 任何模块更新，整个程序需要重新链接
+ 动态链接不对组成程序的目标文件进行链接，等到程序要运行时才进行链接
+ Linux中一般是以".so"文件为扩展名的一些文件，Windows中则以".dll"为扩展名的文件

### 例子
```c
// Program1.c
#include "Lib.h"
int main() {
    foobar(1);
    return 0;
}

// Program2.c
#include "Lib.h"
int main() {
    foobar(2);
    return 0;
}

// Lib.c
#include <stdio.h>
void foobar(int i) {
    printf("Printing from Lib.so %d\n", i);
}

// Lib.h
#ifndef LIB_H
#define LIB_H

void foobar(int i);

#endif
```

```shell
gcc -fPIC -shared -o Lib.so Lib.c
```
+ `shared`表示共享对象
然后分别编译两个c文件：
```shell
gcc -o Program1 Program1.c ./Lib.so
gcc -o Program2 Program2.c ./Lib.so
```

图示过程：
![](https://img-blog.csdnimg.cn/20190524223507682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)

与静态链接不同的地方就是在`Program1.o`被链接成可执行文件的这一步：
+ 在静态链接中，这一步链接过程会把`Program1.o`和`Lib.o`链接到一起，并且产生输出可执行文件`Program1`。
+ 而动态链接中，`Lib.o`没有被链接进来，链接输入的目标文件只有`Program1.o`(先忽略C语言运行库)，参加链接的还有`Lib.so`
    + 当`Program1.c`被编译成`Program1.o`时，编译器还不知道`foobar()`函数的地址，当链接器将`Program1.o`链接成可执行文件时，这时候链接器必须确定`foobar()`函数的性质。如果`foobar()`是一个定义与其他静态目标文件模块中的函数，那么链接器将会按照静态链接的规则，如果`foobar()`是一个定义在某个动态共享对象中的函数，那么链接器会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行
    + 链接器如何知道`foobar`的引用是一个静态符号还是一个动态符号？
    + `Lib.so`中保存了完整的符号信息，把`Lib.so`也作为链接的输入文件之一，链接器在解析符号时就知道：`foobar`是一个定义在`Lib.so`的动态符号，这样链接器就可以对`foobar`的引用做特殊的处理，使它成为一个对动态符号的引用
    + `Lib.so`与`Program1`都被操作系统用同样的方法映射至进程的虚拟地址空间
    + `Program1`除了使用`Lib.so`之外，还用到了动态链接形式的C语言运行时库`libc-2.6.1.so`
    + 还有一个共享对象就是`ld-2.6.so`，它是Linux下的动态链接器，动态链接器与普通对象一样被映射到了进程的地址空间，在系统开始运行`Program1`之前，首先会把控制权交给动态链接器，由它完成所有的链接工作以后再把控制权交给`Program1`，然后开始执行
    + 共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前的地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象


## 没有main函数
程序的真正入口是_start函数，实际上main函数只是用户代码的入口,它会由系统库去调用,在main函数之前,系统库会做一些初始化工作,比如分配全局变量的内存,初始化堆、线程等,当main函数执行完后,会通过exit()函数做一些清理工作,用户可以自己实现_start函数：
```c
#include <stdio.h> 
#include <stdlib.h> 
_start(void) { 
    printf("hello world!/n"); 
    exit(0); 
}
```
执行如下编译命令并运行:
```shell
$ gcc hello_start.c -nostartfiles -o hello_start
$ ./hello_start 
hello world! 
```
这里的 **-nostartfiles** 的功能是Do notuse the standard system startup files when linking,也就是不使用标准的startupfiles,但是还是会链接系统库,所以程序还是可以执行的

也可以自己指定入口函数：
```c
#include <stdio.h> 
#include <stdlib.h> 
int nomain(){
    printf("helloworld!/n"); 
    exit(0); 
} 
```
采用如下命令编译 
```shell
$ gcc hello_nomain.c -nostartfiles -e nomain -o hello_nomain  
```
其中-e选项可以指定程序入口符号， 对比hello_start的符号表发现只是将_start换成了nomain


## 快排优化
1. 对于小数组而言， 快速排序比插入排序要慢， 所以在排序小数组时应该切换到插入排序，一般来说， 5到15间的任意值在多数情况下都能令人满意
2. 三数取中法： 分别取出数组的最左端元素，最右端元素和中间元素， 在这三个数中取出中位数，作为基准元素

## memmove和memcopy
他们的作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。

## 排序算法
![](https://img-blog.csdnimg.cn/20190420172243819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlc3Ricm9va2xpdQ==,size_16,color_FFFFFF,t_70)


## C++内存管理
+ 静态区：保存自动全局变量和static变量（包括static全局和局部变量）。静态区的内容在整个程序的生命周期内都存在，有编译器在编译的时候分配（数据段（存储全局数据和静态数据）和代码段（可执行的代码/只读常量））。
+ 栈：保存局部变量。栈上的内容只在函数范围内存在，当函数运行结束的时候，这些内容也会自动销毁。其特点是效率高但是空间大小有限。
+ 堆：由malloc系列函数或者new操作符分配的内存。其生命周期由free和delete决定。在没有释放之前一直存在，直到函数结束。其特点是使用灵活，空间比较大，但容易出错。


## inline 与 性能
函数调用的开销： 参数压栈、栈帧开辟与销毁、寄存器保存与恢复等

如果函数本身的代码量较小，比函数调用时做的准备工作的代码还小，这时候内联肯定性能较好

由于内联后函数体执行的代码是相邻的，其执行的代码都在同一页面或连续的页面中，如果没有内联，执行到被调用函数时，
需要跳到含有被调用函数的页面执行，而被调用函数所使用的页面很可能不在高速缓存中。也就是说，内联可以使缺页率降低，
速度更快


## 什么时候不需要使用智能指针
+ 指针并不拥有该数据，例如传参或者明确的引用，生命期短于拥有者的用raw ptr
+ 在代码中涉及跟踪一块内存的所有权，分配或取消分配; 智能指针通常可以明确执行这些操作的需要。