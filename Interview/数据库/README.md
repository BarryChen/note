

## 什么是联合索引？及与单列索引之间的区别？
+ 《高性能MySQL》第5章
+ [博客](https://blog.csdn.net/Abysscarry/article/details/80792876)

## 范式
+ 1NF： 字段是最小的的单元不可再分 
+ 2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键
    + 例如(学号，课程)为主键，分数依赖与(学号，课程)
    + 系名只依赖于学号或者课程，因此要分开两个表
+ 3NF：满足2NF,非主键外的所有字段必须互不依赖，消除冗余
    + 例如(学号，系名，宿舍楼)
    + 宿舍楼依赖于系名，所以要分成两个表:(学号，系名),(学号，宿舍楼)


## 事务
ACID：
+ 原子性：在出错时中止事务，并将部分完成的写入全部丢弃
+ 一致性：对数据有特定的预期状态，任何数据更改必须满足这些约束状态，本质上要求应用层来维护
+ 隔离性：并发执行的多个事务相互隔离，不能相互交叉
+ 持久性：保证一旦事务提交成功，即使硬件故障或数据库崩溃，事务所写入的任何数据也不会消失

## 隔离性
### 读-提交
1. 读数据库时，只能看到已提交的数据，防止脏读
    + 维护旧值和将要设置的新值两个版本(后面提到的MVCC)
2. 写数据库时，只会覆盖已成功提交的数据，防止脏写
    + 使用行级锁来防止脏写

#### 问题：
解决不了不可重复读或读倾斜的问题：备份场景和分析查询场景

### 快照级别隔离与可重复读
快照隔离级别是解决上述问题最常见的手段：每个事务都从数据库的一致性快照中读取，
事务一开始所看到的是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到特定时间点的旧数据

#### 实现：
快照级别隔离的实现通常采用写锁来防止脏写，读取不需要加锁

多版本并发控制MVCC：
+ 实现读-提交级别隔离只需要保留对象的两个版本就足够了
+ 当事务开始时，首先赋予一个唯一的、单调递增的事务ID，
每当事务向数据库写入新内容时，所写的数据都会被标记写入者的事务ID
+ 表中每一行都有一个created_by字段，其中包含了创建改行的事务ID，
还有一行是deleted_by字段，初始为空，如果事务删除某行，该行实际上并未从数据库中删除，
而只是将deleted_by字段设置为请求删除的事务ID。事后，当确定没有其他事务引用该标记删除的行时，
数据库的垃圾回收进程才去真正删除并释放存储空间

#### 问题
读-提交和快照级别隔离主要都是问了解决只读事务遇到并发写时可以看到什么，
但如果两个事务并发会有什么问题(脏写是写并发的一个特例)？

解决：原子写操作，显示加锁

### 写倾斜与幻读
并发写引发的问题除了脏写和更新丢失还有其他问题，

写倾斜：两笔事务更新两个不同的对象

幻读：在一个事务中的写入改变了另一个事务查询结果的现象

#### 解决
实体化冲突

可串行化更为可行

### 串行化
#### 两阶段加锁
可能死锁，性能不佳

#### 可串行化的快照隔离SSI
两阶段加锁虽然可以保证串行化，但性能差强人意且无法扩展；
弱级别隔离性虽然性能不错，但是容易引发各种边界问题(更新丢失、写倾斜、幻读等)

可串行化的快照隔离可以避免前面方法的大部分缺点。它秉持乐观预期的原则，允许许多事务并发执行而不互相阻塞；
仅当事务尝试提交时，才检查可能的冲突，如果发现违背串行化，则某些事务会被中止

## 为什么Mysql用B+树做索引而不用B-树或红黑树
+ B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域
+ Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。那么Mysql如何衡量查询效率呢？– 磁盘IO次数
+ B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一
+ 另一个优点是： B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作
+ AVL树和红黑树基本都是存储在内存中才会使用的数据结构
+ 在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况