

## 什么是联合索引？及与单列索引之间的区别？
+ 《高性能MySQL》第5章
+ [博客](https://blog.csdn.net/Abysscarry/article/details/80792876)

## 范式
+ 1NF： 字段是最小的的单元不可再分 
+ 2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键
    + 例如(学号，课程)为主键，分数依赖与(学号，课程)
    + 系名只依赖于学号或者课程，因此要分开两个表
+ 3NF：满足2NF,非主键外的所有字段必须互不依赖，消除冗余
    + 例如(学号，系名，宿舍楼)
    + 宿舍楼依赖于系名，所以要分成两个表:(学号，系名),(学号，宿舍楼)


## 事务
ACID：
+ 原子性：在出错时中止事务，并将部分完成的写入全部丢弃
+ 一致性：对数据有特定的预期状态，任何数据更改必须满足这些约束状态，本质上要求应用层来维护
+ 隔离性：并发执行的多个事务相互隔离，不能相互交叉
+ 持久性：保证一旦事务提交成功，即使硬件故障或数据库崩溃，事务所写入的任何数据也不会消失

## 隔离性
### 读-提交
1. 读数据库时，只能看到已提交的数据，防止脏读
    + 维护旧值和将要设置的新值两个版本(后面提到的MVCC)
2. 写数据库时，只会覆盖已成功提交的数据，防止脏写
    + 使用行级锁来防止脏写

#### 问题：
解决不了不可重复读或读倾斜的问题：备份场景和分析查询场景

### 快照级别隔离与可重复读
快照隔离级别是解决上述问题最常见的手段：每个事务都从数据库的一致性快照中读取，
事务一开始所看到的是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到特定时间点的旧数据

#### 实现：
快照级别隔离的实现通常采用写锁来防止脏写，读取不需要加锁

多版本并发控制MVCC：
+ 实现读-提交级别隔离只需要保留对象的两个版本就足够了
+ 当事务开始时，首先赋予一个唯一的、单调递增的事务ID，
每当事务向数据库写入新内容时，所写的数据都会被标记写入者的事务ID
+ 表中每一行都有一个created_by字段，其中包含了创建改行的事务ID，
还有一行是deleted_by字段，初始为空，如果事务删除某行，该行实际上并未从数据库中删除，
而只是将deleted_by字段设置为请求删除的事务ID。事后，当确定没有其他事务引用该标记删除的行时，
数据库的垃圾回收进程才去真正删除并释放存储空间

#### 问题
读-提交和快照级别隔离主要都是问了解决只读事务遇到并发写时可以看到什么，
但如果两个事务并发会有什么问题(脏写是写并发的一个特例)？

解决：原子写操作，显示加锁

### 写倾斜与幻读
并发写引发的问题除了脏写和更新丢失还有其他问题，

写倾斜：两笔事务更新两个不同的对象

幻读：在一个事务中的写入改变了另一个事务查询结果的现象

#### 解决
实体化冲突

可串行化更为可行

### 串行化
#### 两阶段加锁
可能死锁，性能不佳

#### 可串行化的快照隔离SSI
两阶段加锁虽然可以保证串行化，但性能差强人意且无法扩展；
弱级别隔离性虽然性能不错，但是容易引发各种边界问题(更新丢失、写倾斜、幻读等)

可串行化的快照隔离可以避免前面方法的大部分缺点。它秉持乐观预期的原则，允许许多事务并发执行而不互相阻塞；
仅当事务尝试提交时，才检查可能的冲突，如果发现违背串行化，则某些事务会被中止
