

## 什么是联合索引？及与单列索引之间的区别？
+ 《高性能MySQL》第5章
+ [博客](https://blog.csdn.net/Abysscarry/article/details/80792876)

## 范式
+ 1NF： 字段是最小的的单元不可再分 
+ 2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键
    + 例如(学号，课程)为主键，分数依赖与(学号，课程)
    + 系名只依赖于学号或者课程，因此要分开两个表
+ 3NF：满足2NF,非主键外的所有字段必须互不依赖，消除冗余
    + 例如(学号，系名，宿舍楼)
    + 宿舍楼依赖于系名，所以要分成两个表:(学号，系名),(学号，宿舍楼)


## 事务
ACID：
+ 原子性：在出错时中止事务，并将部分完成的写入全部丢弃
+ 一致性：对数据有特定的预期状态，任何数据更改必须满足这些约束状态，本质上要求应用层来维护
+ 隔离性：并发执行的多个事务相互隔离，不能相互交叉
+ 持久性：保证一旦事务提交成功，即使硬件故障或数据库崩溃，事务所写入的任何数据也不会消失

## 隔离性
### 读-提交
1. 读数据库时，只能看到已提交的数据，防止脏读
    + 维护旧值和将要设置的新值两个版本(后面提到的MVCC)
2. 写数据库时，只会覆盖已成功提交的数据，防止脏写
    + 使用行级锁来防止脏写

#### 问题：
解决不了不可重复读或读倾斜的问题：备份场景和分析查询场景

### 快照级别隔离与可重复读
快照隔离级别是解决上述问题最常见的手段：每个事务都从数据库的一致性快照中读取，
事务一开始所看到的是最近提交的数据，即使数据随后可能被另一个事务更改，但保证每个事务都只看到特定时间点的旧数据

#### 实现：
快照级别隔离的实现通常采用写锁来防止脏写，读取不需要加锁

多版本并发控制MVCC：
+ 实现读-提交级别隔离只需要保留对象的两个版本就足够了
+ 当事务开始时，首先赋予一个唯一的、单调递增的事务ID，
每当事务向数据库写入新内容时，所写的数据都会被标记写入者的事务ID
+ 表中每一行都有一个created_by字段，其中包含了创建改行的事务ID，
还有一行是deleted_by字段，初始为空，如果事务删除某行，该行实际上并未从数据库中删除，
而只是将deleted_by字段设置为请求删除的事务ID。事后，当确定没有其他事务引用该标记删除的行时，
数据库的垃圾回收进程才去真正删除并释放存储空间

#### 问题
读-提交和快照级别隔离主要都是问了解决只读事务遇到并发写时可以看到什么，
但如果两个事务并发会有什么问题(脏写是写并发的一个特例)？

解决：原子写操作，显示加锁

### 写倾斜与幻读
并发写引发的问题除了脏写和更新丢失还有其他问题，

写倾斜：两笔事务更新两个不同的对象

幻读：在一个事务中的写入改变了另一个事务查询结果的现象

#### 解决
实体化冲突

可串行化更为可行

### 串行化
#### 两阶段加锁
可能死锁，性能不佳

#### 可串行化的快照隔离SSI
两阶段加锁虽然可以保证串行化，但性能差强人意且无法扩展；
弱级别隔离性虽然性能不错，但是容易引发各种边界问题(更新丢失、写倾斜、幻读等)

可串行化的快照隔离可以避免前面方法的大部分缺点。它秉持乐观预期的原则，允许许多事务并发执行而不互相阻塞；
仅当事务尝试提交时，才检查可能的冲突，如果发现违背串行化，则某些事务会被中止

## 为什么Mysql用B+树做索引而不用B-树或红黑树
+ B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域
+ Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。那么Mysql如何衡量查询效率呢？– 磁盘IO次数
+ B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一
+ 另一个优点是： B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作
+ AVL树和红黑树基本都是存储在内存中才会使用的数据结构
+ 在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况

## 分布式事务的实现
一旦确定事务中的所有其他节点也将提交，节点就必须进行提交

### 两阶段提交（two-phase	commit）
2PC使用一个通常不会出现在单节点事务中的新组件：协调者（coordinator）（也称为事务 管理器（transaction	manager））

正常情况下，2PC事务以应用在多个数据库节点上读写数据开始。我们称这些数据库节点为 参与者（participants）。当应用准备提交时，协调者开始阶段1：它发送一个准备 （prepare）请求到每个节点，询问它们是否能够提交。然后协调者会跟踪参与者的响应：
+ 如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段2发出提交 （commit）请求，然后提交真正发生。
+ 如果任意一个参与者回复了“否”，则协调者在阶段2中向所有节点发送中止（abort）请求。

详细过程：
1. 当应用想要启动一个分布式事务时，它向协调者请求一个全局唯一的事务ID
2. 应用在每个参与者上启动单节点事务，并在单节点事务上捎带上这个全局事务ID。所有的读写都是在这些单节点事务中各自完成的。如果这个阶段出现任何问题，
如节点崩溃或请求超时，则协调者或任何参与者都可以中止
3. 当应用准备提交时，协调者向所有参与者发送一个准备请求，并打上全局事务ID的标记。
如果任意一个请求失败或超时，则协调者向所有参与者发送针对这个事务ID的中止请求
4. 参与者收到准备请求时，需要确保在任意情况下都的确可以提交事务。这包括将所有事务数据写入磁盘
（出现故障，电源故障，或磁盘空间不足都不能是稍后拒绝提交的理由）以及检查是否存在任何冲突或违反约束。
通过向协调者回答“是”，节点承诺，只要请求，这个事务一定可以不差错的提交。换句话说，参与者放弃了中止事务的权利，但没有实际提交。
5. 当协调者收到所有准备请求时，就会提交或中止事务做出明确的决定（所有参与者投赞成票才会提交）。协调者必须把这个决定写到磁盘上的事务日志中，
如果它随后崩溃，恢复后也知道自己所做的决定，这被称为提交点（commit point）
6. 一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，知道成功为止。
如果参与者在此期间崩溃，事务将在其恢复后提交

### 协调者失效
如果协调者在发送准备请求之前失败，参与者可以安全地中止事务。
但是，一旦参与者收到准备请求并投了“是”，就不能单方面放弃——必须等待协调者回答是否已经提交或中止。
如果此时协调者崩溃或网络出现故障，参与者什么也做不了只能等待。参与者的这种状态称为存疑（in doubt）的或不确定的（uncertain）的

可以完成2PC的唯一方法是等待协调者恢复。这就是为什么协调者必须向参与者发送提交或中止请求之前，
将其提交或中止决定写入磁盘上的事务日志：协调者恢复后，通过读取其事务日志来确定所有存疑事务的状态。
任何协调者日志中没有提交记录的事务都会中止。

### 三阶段提交
简单的说来, 3PC就是把2PC的Commit阶段拆成了PreCommit和Commit两个阶段。 
通过进入增加的这一个PreCommit阶段, 参与者可以得到Propose阶段的投票结果, 但不会commit; 
而通过进入Commit阶段, 参与者可以看出其他每个参与者也都打算commit了, 从而可以放心的commit

换言之, 3PC在2PC的Commit阶段里增加了一个barrier(即相当于告诉其他所有参与者, 我收到了Propose的结果啦)
+ 在这个barrier之前coordinator掉线的话, 其他参与者可以得出结论不是每个参与者都收到Propose Phase的结果, 从而放弃或选出新的coordinator; 
+ 在这个barrier之后coordinator掉线的话, 每个参与者会放心的commit, 因为他们知道其他参与者也都做同样的计划

### 3PC的缺陷：不能处理网络分区
3PC可以有效的处理fail-stop的模式, 但不能处理网络划分(network partition)的情况---节点互相不能通信. 

假设在PreCommit阶段所有节点被一分为二, 收到preCommit消息的参与者在一边, 而没有收到这个消息的在另外一边. 在这种情况下, 两边就可能会选出新的coordinator而做出不同的决定.

